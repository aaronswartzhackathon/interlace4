<html>
  <head>
<title>timelines</title>
<script src="freud.js"></script>
<script src="inline.js"></script>
<style>
body {
  margin: 0;
}
</style>
</head>
<body>
<h1>timelines</h1>
<a href="upload.html">upload</a>
<script>

var PREFS = {
    "overview": {
        "row_t": 600,
        "row_w": 1200,
        "row_h": 72,
        "img_w": 50,
        "nrows": 10
        },
    "detail": {
        "row_t": 60,
        "row_w": 1200,
        "row_h": 72,
        "img_w": 72,
        "nrows": 10
        }
    }
var ego = new SuperEgo();
ego.track();

var loader = new ImageLoader();

var videos = new Subcollection(ego, function(x) {
    return x.type == "video";
});

function v_duration(v) {
    // XXX: index method undershoots by one cluster -- need to store duration in doc
    return v.duration || v.index[v.index.length-1];
};
function zeropad(number, length)
{
    var pad = "";
    for (var i=0; i<length-String(number).length; i++) {
	    pad += "0";
    }
    pad += String(number);
    return pad;
}
function v_overview(v, idx) {
    return "db/" + v._id + "/overview-" + zeropad(idx, 6) + ".jpg";
};

var OverviewLine = function(src, idx) {
    Line.call(this, PREFS.overview.row_h);
    this.src = src;
    this.idx = idx;
};
OverviewLine.prototype = new Line;
OverviewLine.prototype.time2px = function(t) {
    return t * (PREFS.overview.row_w / PREFS.overview.row_t);
};
OverviewLine.prototype.px2time = function(x) {
    return x / (PREFS.overview.row_w / PREFS.overview.row_t);
};
OverviewLine.prototype.getDuration = function() {
    var max_mosaic_dur = PREFS.overview.row_t * PREFS.overview.nrows;
    return Math.min(max_mosaic_dur, v_duration(this.src) - this.idx * max_mosaic_dur);
}
OverviewLine.prototype.render = function(ctx, args) {
    var cur_x = args.px_start;
    while(cur_x < (args.px_start + args.ctx_w)) {

        // Blit one line of overview at a time.
        // XXX: This is ill-suited to adding zoom.

        var sx = cur_x % PREFS.overview.row_w;
        var sy = PREFS.overview.row_h * Math.floor(cur_x / PREFS.overview.row_w);
        var line_w = Math.min(
            // Width available within the overview line
            PREFS.overview.row_w - sx,
            // Width available in the canvas context
            args.ctx_w - (cur_x - args.px_start));

        loader.loadImage(v_overview(this.src, this.idx), function($img) {

            ctx.drawImage($img,
                          // sx, sy, sw, sh
                          this.sx, this.sy, this.line_w, PREFS.overview.row_h,
                          // dx, dy, dw, dh
                          args.ctx_start_x + this.cur_x - args.px_start, 0, this.line_w, PREFS.overview.row_h);

            // Line.prototype.debug_render.call(this.line, ctx, args);

        }.bind({ctx: ctx, cur_x: cur_x, sx: sx, sy: sy, line_w: line_w, line: this}));

        cur_x += line_w;
    }
};

var SourceLine = function(src) {
    // Make a timeline of an entire source.
    // This wraps as many OverviewLines as necessary.
    var dur = v_duration(src);
    var overviews = [];
    var idx = 0;
    while(idx * PREFS.overview.row_t * PREFS.overview.nrows < dur) {
        overviews.push(new OverviewLine(src, idx));
        idx += 1;
    }

    MultiLine.call(this, overviews);
};
SourceLine.prototype = new MultiLine;
// SourceLine.prototype.render = function($can, px_start, args) {
//     console.log("SL RENDER", $can.width, px_start, args, this.lines[0].src["uploaded-file-name"]);
//     MultiLine.prototype.render.call(this, $can, px_start, args);
// }


var line, flow;
ego.onload = function() {
    line = new MultiLine(videos.items().map(function(x) { return new SourceLine(x); }));
    flow = new Flow(line, document.body.clientWidth);

    document.body.appendChild(flow.$el);

    flow.setVisible(0,document.body.clientHeight);
}

</script>
</body>
</html>
